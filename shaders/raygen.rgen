#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : require

#include "random.h"
#include "shaderCommon.h"

const int MAX_MATERIALS = 100;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0) uniform CameraProperties
{
	mat4 viewInverse;
	mat4 projInverse;
	vec4 position;
} cam;
layout(binding = 2, set = 0) uniform sampler2D gbuffers[]; // 0 = position, 1 = normal, 2 = albedo
layout(binding = 7, set = 0) uniform Lights { Light l[5]; } lights;
layout(binding = 8, set = 0) buffer Materials { Material m[]; } materials;
layout(binding = 10, set = 0, rgba8) uniform image2D image;
layout(binding = 11, set = 0, rgba8) uniform image2D denoisedShadowTextures[];
layout(binding = 12, set = 0, rgba8) uniform image2D shadowImages[];

layout( push_constant ) uniform RtPushConstant {
	int frame;
} pushConstant;

// Payload
layout(location = 0) rayPayloadEXT RayPayload prd;
layout(location = 1) rayPayloadEXT ShadowRayPayload shadowPrd;

const uint MAX_RECURSION = 10;

void main() 
{
	prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pushConstant.frame);
	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	vec2 gbufferUV = vec2(pixelCenter.x / gl_LaunchSizeEXT.x, pixelCenter.y / gl_LaunchSizeEXT.y);
	
	vec3 worldPos = texture(gbuffers[0], gbufferUV).xyz;
	vec3 N = normalize(texture(gbuffers[1], gbufferUV).xyz * 2.0 - vec3(1.0));
	vec3 albedo = texture(gbuffers[2], gbufferUV).xyz;
	int matIdx = int(texture(gbuffers[2], gbufferUV).w * MAX_MATERIALS);

	Material material = materials.m[matIdx];

	// Material properties
	float roughness = material.roughness_metallic_tilling_color_factors.x;
	float metal = material.roughness_metallic_tilling_color_factors.y;
	float tilling = material.roughness_metallic_tilling_color_factors.z;
	vec3 color_material = material.color.xyz;

	//calculate f0 reflection based on the color and metalness
	vec3 f0 = albedo * metal + (vec3( 0.5 ) * ( 1.0 - metal ));

	//COMPUTE LIGHT
	vec3 totalLight = vec3(0);

	for(int i = 0; i < 1; i++)
	{
		// light info
		float lightIntensity = lights.l[i].color_intensity.w;
		float lightMaxDist  = lights.l[i].position_maxDist.w;
		vec3 lightPosition = lights.l[i].position_maxDist.xyz;
		float radius = lights.l[i].radius;

		// Point light
		vec3 lDir      = lightPosition - worldPos;
		float lightDistance  = length(lDir);

		vec3 L = normalize(lDir);
		vec3 V = normalize( cam.position.xyz - worldPos );
		vec3 H = normalize( L + V );
		float NdotL = clamp( dot( N, L ), 0.0, 1.0 );
		float NdotV = clamp( dot( N, V ), 0.0, 1.0 );
		float NdotH = clamp( dot( N, H ), 0.0, 1.0 );
		float LdotH = clamp( dot( L, H ), 0.0, 1.0 );

		float attenuation = computeAttenuation( lightDistance,  lightMaxDist );
		float shadowFactor = 1.0;
		
		//calulate the specular and diffuse
		vec3 diffuse = ( 1.0 - metal ) * albedo * color_material;	//the more metalness the less diffuse color
		vec3 ks = specularBRDF( roughness, f0, NdotH, NdotV, NdotL, LdotH );
		vec3 kd = diffuse * NdotL;
		vec3 direct = kd + ks;

		totalLight += direct * lights.l[i].color_intensity.xyz * lightIntensity * attenuation * shadowFactor;
	}

	prd.direction.xyz = vec3(0);

	vec4 origin = vec4(worldPos, 1);

    vec3 finalColor = vec3(0.0);
	finalColor = albedo * totalLight;
	finalColor = albedo;

	// Do accumulation over time
	/*
	if(pushConstant.frame > 0)
	{
		float a         = 1.0f / float(pushConstant.frame + 1);
		vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, finalColor, a), 1.0f));
	}
	else
	{
		// First frame, replace the value in the buffer
		imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0f));
	}
	*/

	vec3 shadowColor = imageLoad(shadowImages[0], ivec2(gl_LaunchIDEXT.xy)).xyz;

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(shadowColor, 1.0f));
}