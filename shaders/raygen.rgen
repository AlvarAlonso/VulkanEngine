#version 460
#extension GL_EXT_ray_tracing : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
	vec4 position;
} cam;

struct RayPayload {
	vec4 color_dist;
	vec4 direction;
	vec4 origin;
};

layout(location = 0) rayPayloadEXT RayPayload rayPayload;

uint tea( uint val0, uint val1 );
uint lcg(inout uint prev);
float rnd(inout uint prev);

const uint MAX_RECURSION = 10;

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	float tmin = 0.001;
	float tmax = 10000.0;

    vec3 finalColor = vec3(0.0);

	for(int i = 0; i < MAX_RECURSION; i++)
	{
	    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

		const vec3 hitColor = rayPayload.color_dist.xyz;
		const float dist = rayPayload.color_dist.w;
		const bool bounce = rayPayload.direction.w > 0;

		if (dist < 0.0f) { //miss
			finalColor += hitColor;
			break;
		}
		else if(!bounce) //diffuse
		{
			finalColor += hitColor;
			vec3 N = rayPayload.direction.xyz;
			origin.xyz = rayPayload.origin.xyz;
			direction.xyz = N;
			/*
			vec3 irradiance = vec3(0);

			for(int j = 0; j < 24; j++)
			{
				traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);

				uint seed1 = uint(origin.x);
				uint seed2 = uint(origin.y);

				uint prev1 = tea(seed1, seed2);
				uint prev2 = tea(seed1, seed2);
				uint prev3 = tea(seed1, seed2);

				direction.xyz = vec3(rnd(prev1), rnd(prev2), rnd(prev3));
				normalize(direction.xyz);

				float NdotD = dot(N, direction.xyz);
				
				irradiance += rayPayload.color_dist.xyz;
			}

			finalColor; //+= irradiance / 5000;
			*/
			break;
		}
		else
		{
			origin.xyz = rayPayload.origin.xyz;
			direction.xyz = rayPayload.direction.xyz;
			finalColor += hitColor;
		}
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 0.0));
}

uint tea( uint val0, uint val1 )
{
    uint v0 = val0;
    uint v1 = val1;
    uint s0 = 0;

    for( uint n = 0; n < 16; n++ )
    {
        s0 += 0x9e3779b9;
        v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
        v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
    }

    return v0;
};

// Generate a random unsigned int in [0, 2^24) given the previous RNG state
// using the Numerical Recipes linear congruential generator
uint lcg(inout uint prev)
{
  uint LCG_A = 1664525u;
  uint LCG_C = 1013904223u;
  prev       = (LCG_A * prev + LCG_C);
  return prev & 0x00FFFFFF;
};

// Generate a random float in [0, 1) given the previous RNG state
float rnd(inout uint prev)
{
  return (float(lcg(prev)) / float(0x01000000));
};